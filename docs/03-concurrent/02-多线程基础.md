# 02 多线程基础

+ 什么是线程
+ 线程的基本操作
+ 守护线程
+ 线程的优先级
+ 基本的线程同步操作

### 1、什么是线程

 - 线程是进程内的执行单元
 
>比如任务管理器中的进程，右键点击“设置相关性”，可以选择这个进程执行的cpu，默认全选随机。

> java中的线程会直接映射到操作系统的线程中，在linux中调用线程与window中调用线程是等价的。

### 2、线程的基本操作

+ 线程的状态
+ 新建线程
+ 终止线程
+ 中断线程
+ 线程的挂起（suspend）和继续执行（resume）
+ 等待线程结束（join）和谦让（yeild）

>线程的终止，中断，挂起，等待，谦让，都是监视对象操作的。

+ 线程类，同步锁，锁的监视对象。
* 线程类表示：我们创建的线程类，里面写的执行代码。
* 同步锁：给代码中某些操作添加锁，同一时间只让一个线程进行执行。
* 锁监视对象：线程的终止，中断，挂起，等待，谦让，都是监视对象操作的。

####2.1 线程的状态
	
+ NEW: 新建状态，只是一个实例。
+ RUNNABLE：执行start方法。
+ TERMINATED：执行完成。
+ BLOCKED：synchronized 加锁，竞争。
+ WAITING：调用wait方法
+ TIMED_WATING: 调用wait(1000)方法，等待1000毫秒

####2.2 新建线程
```
	Thread t1=new Thread(); t1.start();
	
Thread.run()的实现 target 是Runnable接口 

	public void run() { if (target != null) { target.run(); }
	
	Thread t1=new Thread();
	t1.run(); //不能开启线程
	
	Thread t1=new Thread(){ 
		@Override public void run(){ 
			System.out.println("Hello, I am t1"); 
		} 
	}; 
	t1.start();
	
	Thread t1=new Thread(new CreateThread3());
	t1.start();
```
####2.3 终止线程

- Thread.stop() 不推荐使用。它会释放所有monitor
- 该方法导致数据不正确。

记录1：ID=1，NAME=小明
记录2：ID=2，NAME=小王

> stop方法导致线程执行一半，就结束了，导致数据不一致；比如某线程需要修改user对象 id = 1、name = 小明，刚好在修改id=1，但name没有修改时候，结束了，这时该记录就是 id= 1,name = null。数据严重不一致。期望会是id和name都修改完成。

####2.4 中断线程
```
 - public void Thread.interrupt() // 中断线程 
 - public boolean Thread.isInterrupted() // 判断是否被中断
 - public static boolean Thread.interrupted() // 判断是否被中断，并清除当前中断状态
```
> interrupt，表示其他线程给这个线程发送一个消息，打个招呼，这个线程可以收到，并做出相应操作。
比如，终止线程操作。示例如下：

> 所有等待Thread.sleep(), 等待的方法都会抛出InterruptException, 表示在等待过程中，如果有其他线程发送这个消息，就抛出异常，以便对这个消息做处理。并且会清空这个终端标志位。

```
	public void run(){
		 while(true){ 
		 		if(Thread.currentThread().isInterrupted()){ 
		 				System.out.println("Interruted!"); 
		 				break; 
		 		} 
		 		Thread.yield(); 
		 } 
	}
	
	public static native void sleep(long millis) throws InterruptedException
		public void run(){
			while(true){
				if(Thread.currentThread().isInterrupted()){
					System.out.println("Interruted!");
					break;
				}
				try {
					Thread.sleep(2000);
				} catch (InterruptedException e) {
					System.out.println("Interruted When Sleep");
					//设置中断状态，抛出异常后会清除中断标记位
					Thread.currentThread().interrupt();
				}
				Thread.yield();
			}
		}
	}
```
####2.5 挂起（suspend）和继续执行（resume）
	
–suspend()不会释放锁
–如果加锁发生在resume()之前 ，则死锁发生

> suspend 执行挂起后，不会释该线程占的资源，直到监视对象调用resume方法时，才会执行。如果，suspend执行在 resume之后，则导致对象永久挂起，不会释放。



####2.6 等待线程结束(join)和谦让（yeild）

 - yeild谦让：Object.yeild()把当前cpu时间让出，让其他线程执行，下一次继续竞争。测试debug时候使用。
 - join等待结束：Object.join()不知道线程什么结束，调用这个方法，表示线程以执行完成，在执行其他。
 - join 实现：判断线程是否执行结束，调用wait方法。不推荐调用Object.wait,Object.notify,方法，系统自动调用。

 - public final void join() throws InterruptedException
 - public final synchronized void join(long millis) throws InterruptedException

```
	public class JoinMain { 
		public volatile static int i=0; 
		public static class AddThread extends Thread{ 
			@Override public void run() { 
				for(i=0;i<10000000;i++); 
				} 
			} 
		public static void main(String[] args) throws InterruptedException { 
			AddThread at=new AddThread(); 
			at.start(); 
			at.join(); 
			System.out.println(i);
		}
	}
```

> 不要在Thread实例上使用 wait()和notify()方法

> join的本质 while (isAlive()) { wait(0);}

> 线程执行完毕后，系统会调用notifyAll()

###3、守护线程

 - 后台默默地完成一些系统性的服务，比如垃圾回收、JIT线程就可以理解为守护线程。
 - 当一个java应用程序中，只有守护线程，java虚拟机就会自然退出。
 
	Thread t = new DaemonT();
	t.setDaemon(true);
	t.start(); 
	//马上结束  

###4、线程的优先级

 - 高优先级的线程更容易在竞争中获胜，获得执行机会，优先执行完成。
 - Thread.MAX_PRIORITY()、Thread.MIN_PRIORITY();

	Thread high=new HightPriority();
	LowPriority low=new LowPriority();
	high.setPriority(Thread.MAX_PRIORITY);
	low.setPriority(Thread.MIN_PRIORITY);
	low.start();
	high.start();
	
###5、基本的线程同步操作

+ sychrounized
	* 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁。
	* 直接作用于实例方法：相当于对象实例加锁，进入同步代码前要获得当前实例的锁。
	* 直接作用于静态方法：相当于当前类的锁，进入同步代码前要获得当前类的锁。

>指定加锁对象

	public void run() { for(int j=0;j<10000000;j++){ synchronized(instance){ i++; } } }
	
>用在方法上

	public synchronized void increase(){ i++; }
	public static synchronized void increase(){ i++; }
	
+ Object.wait, Object.notify(), Object.nofityAll();

> Object.wait, 调用时候必须获得该对象的monitor，也就是在sychrounized(object)内部;此方法调用后释放当前对象（object）执行所有权(不然其他线程无法获得)，等待其他线程唤醒（调用Object.notify()）

> Object.notify, 调用时候也必须获得该对象的monitor，也及时在sychrounized（object）内部；此方法调用后说明该线程执行完成后释放后唤醒object等待的线程。

> Object.nofity, 随机唤醒一个Object上等待的线程；Object.notifyAll，唤醒所有Object上等待的线程。

