# 09-锁的优化和注意事项

+ 1.锁优化的思路和方法
+ 2.虚拟机内的锁优化
+ 3.一个错误使用锁的案例
+ 4.ThreadLocal及源码分析

参考资料：http://www.cnblogs.com/charlesblc/p/5994162.html

##1.锁优化的思路和方法
###1.1减少锁的持有时间
  //方法1
  public synchronized void syncMethod(){
  	 othercode1();
  	 mutextMethod();
  	 othercode2();
  }
  //方法2
  public void syncMethod2(){
  	 othercode1();
  	 synchronized(this){
  	 	mutextMethod();
  	 }
  	 othercode2();
  }
  说明：方法2相比方法1，减少了加锁的代码，从而减少等待时间，提高效率。

###1.2减小颗粒度
- 将大对象，拆成小对象，大大增加并行度，降低锁竞争
- 偏向锁，轻量级锁成功率提高
- ConcurrentHashMap
- HashMap的同步实现
  - Collections.synchronizedMap(Map<K, V> m);
  - 返回SynchronizedMap对象
  public V get(Object key){
  	 synchronized(mutext){return m.get(key);}
  }
  public V put(K key, V value){
  	 synchronized(mutext){return m.put(key, value);}
  }
  
- ConcurrentHashMap 
  - 若干个Segment: Segment<K, V>[] segments
  - Segment中维护HashEntry<K, V>
  - put操作时, 先定位到segment, 锁定一个segment, 再执行put
- 减小颗粒度后，ConcurrentHashMap允许若干个线程同时进入 

###1.3锁分离
- 根据功能进行锁分离
- ReadWriteLock
- 读多写少的情况下可以提高性能，因为将读时候可以不用加锁，提高了性能

| |读锁|写锁|
|-|-|-|
|读锁|可访问|不可访问|
|写锁|不可访问|不可访问|

- 读写分离思想可以延伸，只要操作互不影响，就可以分离
- LinkedBlockingQueue
  - 队列
  - 链表
  ![](./images/blockingqueue.png)

###1.4锁粗化
- 通常情况下，为了保证多线程之间有效的并发，会要求每个线程持有锁的时间尽可能短，即在使用完公共资源后立即释放锁，只有这样，等待这个锁的其他线程才能尽早获得资源执行任务。
- 但是，凡事有个度，如果同一个锁不停的进行请求、同步和释放，其本身会消耗系统宝贵资源，反而不利于性能。
- 示例1
  public void demoMethod(){
    synchronized(this){
      //do sth1
    }
    //做其它不需要同步的工作，但能很快执行完毕
    synchronized(this){
      //do sth2
    } 
  }
  
  public void demoMethod(){
    synchronized(this){
      //do sth1
      //做其它不需要同步的工作，但能很快执行完毕
      //do sth2
    }
  }
- 示例2
  for(int i=0;i<CIRCLE;i++){
     synchronized(lock){
     //do sth
     }
  }
  synchronized(lock){
     for(int i=0;i<CIRCLE;i++){ } 
  }

###1.5锁消除
- 在即时编译时，如果发现不能被共享的对象，则可以消除这些对象的锁操作
![](./images/lock-xiaochu.png)
![](./images/lock-xiaochu2.png)


##2.虚拟机内的锁优化
###2.1对象头Mark
- Mark Word,对象头标记，32位
- 描述对象的hash、锁信息，垃圾回收标记，年龄
  - 指向锁记录的指针
  - 指向monitor的指针
  - GC标记
  - 偏向锁线程ID

###2.2偏向锁
- 大部分锁是没有竞争的，所以可以通过偏向来提高性能
- 所谓偏向，即偏心，锁会偏向当前已占有锁的线程
- 对象头Mark的标记设置为偏向，并将线程ID写入对象头Mark
- 只要没有竞争，获得偏向锁的线程，在将来同步块，不需要做同步
- 当前其他线程请求相同锁时，偏向模式结束
- -XX:+UseBiasedLocking
  - 默认启用
- 在竞争激烈的场合，偏向锁会增加系统负担

![](./images/lock-pianxiangsuo.png)
![](./images/lock-pianxiangsuo2.png)

###2.3轻量级锁
- BasicObjectLock
  - 嵌入在线程栈的对象
  ![](./images/lock-xianchengzhan.png)

- 普通的锁处理性能不够理想，轻量级锁是一种快速的锁定方法
- 如果对象没有被锁定
  - 将对象头的Mark指针保存到锁对象中
  - 将对象头设置为偏向锁的指针（在线程站空间）
  ![](./images/lock-qingliangji.png)
  
- 如果轻量级锁失败，表示存在竞争，升级为重量级锁（常规锁）
- 在没有锁竞争的前提下，减少传统使用OS互斥量产生的性能损耗
- 在竞争激烈时，轻量级锁会做很多额外操作，导致性能下降

###2.4自旋锁
- 当竞争存在时，如果线程可以很快获得锁，那么可以不再再OS上挂起线程，让线程做几个空操作（自旋）
- JDK1.6中 -XX:+UseSpining开启
- JDK7中去掉此参数，改为内置实现
- 如果同步块过长，自旋失败会降低性能
- 如果同步块很短，自旋成功，节省线程切换挂起时间，提升系统性能。

###2.5偏向锁，轻量级锁，自旋锁总结
- 不是java语言层面的锁优化方法
- 内置于JVM中的获取锁的优化方法和获取锁的步骤
	- 偏向锁会优先尝试偏向锁
	- 轻量级锁会优先尝试轻量级锁
	- 以上都失败，使用自旋锁
	- 再失败，使用普通锁，使用OS互斥量在操作系统层挂起 

##3.一个错误使用锁的案例
![](./images/lock-err-demo.png)

##4.ThreadLocal及源码分析
- 为每个线程分配一个实例
    static ThreadLocal<SimpleDateFormat> tl = new ThreadLocal<SimpleDateFormat>();
	public static class ParseDate implements Runnable{
	   int i = 0;
	   public ParseDate(int i){
	      this.i = i;
	   }
	   public void run(){
	      try{
	         if(tl.get() == null){
	            tl.set(new SimpleDateFormat("yyyy-MM-DD HH:mm:ss"));   
	         }
	         Date t = t.get().parse("2015-03-29 19:29:" + i%60);
	         System.out.println(i + ":" + t);
	      }catch(ParseException e){
	         e.printStackTrace()
	      }
	   }
	}
	public static void main(String[] args){
		ExecutorService es = Executors.newFixedThreadPool(10);
		for(int i=0; i< 1000; i++){
		   es.execute(new ParseDate(i));
		}
	}

- 如果使用共享线程，起不到效果
![](./images/threadlocal1.png)

- 源码参见JDK


