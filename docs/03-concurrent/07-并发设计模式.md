#07-并发设计模式

+ 1. 什么是设计模式
+ 2. 单例模式
+ 3. 不变模式
+ 4. Future模式
+ 5. 生产者消费者
+ 6. 反应器（Reactor）模式

##1.什么是涉及模式
- 概念：
  在软件工程中，设计模式（Design Pattern）是对软件中普遍存在（反复出现）的各种问题，所提出的解决方案。
  这个术语是由埃里希-伽玛（Erich Gamma）等人在1990年建筑设计领域引入到计算机科学的。
- Gof
- 《设计模式：可复用面向对象软件的基础》收录23中模式
  - 观察者
  - 策略
  - 模版
  - 装饰器
  - 享元
  
- 架构模式
  - MVC 
  - 分层
- 设计模式
  - 提炼系统中的组件
- 代码模式
  - 低层次，与编码直接相关
  - 如DCL

##2. 单例模式
- 单例对象的类必须保证只有一个实例的存在。许多时候整个系统只需要有一个全局对象，这样有利于我们协调系统整体的行为。
- 比如：全局信息配置
- 简单例子（合时产生示例，不好控制）

public class Singleton {
	private Singleton(){
	 	System.out.println("Singleton is create");
    } 
    private static Singleton instance = new Singleton();
    public static Singleton getInstance() {
     	return instance;
    }
}

public class LazySingleton{
	private static Singleton instance;
	public static synchronized LazySingleton getInstance() { 
		if (instance == null) 
	    	instance = new LazySingleton();
	    return instance; 
	}
}


##3. 不变模式（final）
- 一个类的内部状态创建后，在整个生命周期期间都不会发生变化时，就是不变类。
- 不变模式不需要同步
- 示例

public final class Product { 
	//确保无子类 
	private final String no; 
	//私有属性，不会被其他对象获取 
	private final String name; 
	//final保证属性不会被2次赋值 
	private final double price; 
	public Product(String no, String name, double price) { //在创建对象时，必须指定数据 
		super(); 
		//因为创建之后，无法进行修改 
		this.no = no; 
		this.name = name;
		this.price = price; 
	} 
	public String getNo() { 
		return no; 
	} 
	public String getName() { 
		return name; 
	} 
	public double getPrice() { 
		return price; 
	} 
}

- 不变模式类 String与8种基本数据类型封装类
  - java.lang.String
  - java.lang.Boolean
  - java.lang.Byte
  - java.lang.Character
  - java.lang.Double
  - java.lang.Float
  - java.lang.Integer
  - java.lang.Long
  - java.lang.Short

- final三种用法：成员，方法，类
  - final成员变量（通常表示常量）
  	当你在类中定义变量时，加上final关键字，那便是说，这个变量一旦初始化不可变。
  	这里的不可变是指对基本类型来说不可变，而对于对象变量来说其引用不可再变，但引用变量所指向的对象中的内容还是可以改变的。
  	初始化可以在三个地方：1,定义时直接赋值；2,构造函数中；3,初始化代码块{}或static{}
  	举例如下：
  	import java.util.ArrayList;
	import java.util.LinkedList;
	import java.util.List;
	public class Bat {
		final double PI = 3.14; // 在定义时便给址值
		final int i; // 因为要在构造函数中进行初始化，所以此处便不可再给值
		final List list; // 此变量也与上面的一样
		Bat() {
			i = 100;
			list = new LinkedList();
		}
		Bat(int ii, List l) {
			i = ii;
			list = l;
		}
		public static void main(String[] args) {
			Bat b = new Bat();
			b.list.add(new Bat());// 引用不可变，但引用指向的内容是可以变的
			// b.i = 25; // syntax error i是不可变的
			// b.list = new ArrayList();// 错误，对象引用是不可变的
			System.out.println("I=" + b.i + " List Type:" + b.list.getClass());
			b = new Bat(23, new ArrayList());
			b.list.add(new Bat());
			System.out.println("I=" + b.i + " List Type:" + b.list.getClass());
		}
	}
	final StringBuffer a=new StringBuffer("immutable");
	//a=new StringBuffer(""); //错误，对象引用是不可变的
	a.append("broken!");
	
  - final方法
  	将方法定义为final,表示方法不可变，也就是此方法满足了需求，不需要进行扩展。并且不允许继承此类来覆盖这个方法，但是子类可以复用这个方法。
  - final类
    final修饰类，表示类不可变，也就时不能被继承。并认为此类很完美，不需要进行扩展。final类中的成员变量可以是final，也可以不是final；但final类方法自然不能被覆盖。

##4. Future模式
- Future核心思想
  核心思想时异步调用
  ![](./images/future.png)

- Future模式
  ![](./images/futurePattern.png)

|参与者| 作用|
|------|-----|
|Main| 系统启动，调用Client发出请求|
|Client|返回Data对象，立即返回FutureData,并开启ClientThread线程装配RealData|
|Data|返回数据的接口|
|FutureData|Future数据，构造很快，但是是一个虚拟的数据，需要装配RealData|
|RealData|真实数据，其构造是比教慢的|

- 代码示例
  //数据接口
  public interface Data{
  		public String getResult();
  }	
  //FutureData
  public class FutureData implements Data{
	  	protected RealData realdata = null; // FutureData是RealData的包装
	  	protected boolean isReady = false;
	  	public synchronized void setRealData(RealData realData){
	  		if(isReady){
	  			return;
	  		}
	  		this.realdata = realdata;
	  		this.isReady = true;
	  		notifyAll();//RealData已经被注入，通知getResult();
	  	}
	  	//会等待RealData构造完成
	  	public synchronized String getResult(){
	  		while(!isReady){
	  			try{
	  				wait();//一直等待，直到RealData被注入
	  			}catch(InterruptedException e){
	  			}
	  		}
	  		return realdata.result; //由RealData实现
  		}
  }
  //RealData
  public class RealData implements Data{
  		protected final String result;
  		public RealData(String para){
  			//RealData的构造可能很慢，需要用户等待很久，这里使用sleep模拟
  			StringBuffer sb = new StringBuffer();
  			for(int i=0; i<10; i++){
  				sb.append(para);
  				try{
	  				Thread.sleep(100);
  				}catch(InterruptedException e){
  				}
  			}
  			result = sb.toString();
  		}
  		public String getResult(){
  			return result;
  		}
  }
  //Client
  public class Client{
  		public Data request(final String queryStr){
  			final FutureData  future = new FutureData();
  			//RealData构建比较慢，在线程中进行
  			new Thread(){
  				public void run(){
  					RealData realData = new RealData(queryStr);
  					//构建完成设置到future中
  					future.setRealData(realData);
  				}
  			}.start();
  			return future;//futureData会被立即返回
  		}
  }
  //main
  public static void main(String[] arg){
  		Client client = new Client();
  		Data data = client.request("name");
  		System.out.println("请求完毕");
  		try{
  			//这里用sleep代替其它业务逻辑的处理
  			//在处理这些业务逻辑的过程中，RealData被创建，从而充分利用了等待时间
	  		Thread.sleep(2000);
  		}catch(InterruptedException e){
  		}
  		System.out.println("使用真实数据："+ data.getResult());
  }
  
- JDK对Future模式的支持
  ![](./images/jdkfuture.png)
  
- 简单例子
  public class FutureMain{
	public static void main(String[] args)throws InterruptedException, ExecutionException{
		//构造FutureTask
		FutureTask<String> future = new FutureTask<String>(new RealData("a"));
                ExecutorService executor = Executors.newFixedThreadPool(1);
                //执行FutureTask,相当于上例中client.request("a")发送请求
		//在这里开启线程进行RealData的call发送请求
		executor.submit(future);
		System.out.println("请求完毕");
		try{
			//这里依然可以做额外的数据操作，这里使用sleep代替其他业务逻辑的处理
			Thread.sleep(2000);
		}catch(InterruptedException e){
		}
		//相当于data.getResult(),取得call方法的返回值
      		//如果此时call方法没有执行完成，则依然会等待
		System.out.println("数据=" + future.get());
	}
  }

##5. 生产者消费者模式

- 概念
	生产者-消费者模式时一个经典的多线程设计模式。它为多线程间的协作提供了良好的解决方案。
	在生产者-消费者模式中，通常由两类线程，即若干个生产者线程和若干个消费者线程。
	生产者线程负责提交用户请求，消费者线程负责具体处理生产者提交的任务。生产者和消费者之间则通过共享内存缓冲区进行通信。
	
- 原理图
	![](./images/pro-cus.png)
	![](./images/pro-cus2.png)
- 解释
	
|角色|作用|
|--|--|
|生产者|用于提交用户数请求，提取用户任务，并装入内存缓冲区|
|消费者|在内存缓存中提取并处理任务|
|内存缓冲区|在内存缓冲区提取并处理任务|
|任务|生产者向内存缓冲区提交的数据结构|
|Main|使用生产者和消费者客户端|

- 队列缓冲区
	private BlockingQueue<PCData> queue;
	
- 提交任务
	while (isRunning) { 
		Thread.sleep(r.nextInt(SLEEPTIME)); 
		data = new PCData(count.incrementAndGet()); //构造任务数据 
		System.out.println(data+" is put into queue"); 
		if (!queue.offer(data, 2, TimeUnit.SECONDS)) { //提交数据到缓冲区中 
			System.err.println("failed to put data：" + data); 
		} 
	}
	
- 取任务处理

while(true){ 
    PCData data = queue.take(); 
    //提取任务
    if (null != data) {
  		int re = data.getData() * data.getData(); //计算平方 			
  		System.out.println(MessageFormat.format("{0}*{1}={2}", 		data.getData(), data.getData(), re)); 		Thread.sleep(r.nextInt(SLEEPTIME)); 
   } 
}

