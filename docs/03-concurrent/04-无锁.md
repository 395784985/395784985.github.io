#04-无锁

+ 1.无锁类的原理详解
	+ 1.1 CAS
	+ 1.2 CPU指令
+ 2.无锁类的使用
	+ 2.1 AtomicInteger
	+ 2.2 Unsafe
	+ 2.3 AtomicReference
	+ 2.4 AtomicStampedReference
	+ 2.5 AtomicIntegerArray
	+ 2.6 AtomicIntegerFieldUpdater
+ 3.无锁算法详解
	+ 3.1 无锁的Vector实现
	
##1、无锁类原理详解

+ 1.1 CAS
+ 1.2 CPU指令

###1.1 CAS

- 无锁：

> 无障碍运行，所有线程都能同时进入临界区，基础上增加了一条，多条线程竞争时候必然能决定一个优胜者，不能都失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，也允许失败的线程放弃操作。

> 相对无障碍来讲，理论上说可能是一个比较更加切实可行的方案。
> 当然，也不是决定，实践中，无障碍跟无等待比较接近。
> 理论上来讲，无障碍看起来有可能线程有可能永远出不去。实际上，运气不会那么差。

- CAS：

> 对数据赋值，临界区被保护数据，多个线程同时进来，应该只有一个线程能成功，怎么判断哪个可以成功，要求说我在数据进行操作时候，要给出一个期望值。
> 如果期望值跟数据跟实际的值是相符的，那么就可以设置上去，否则只能失败。
> 如果期望值跟数值跟实际的值不相符，说明在操作过程中已经被其他线程修改过了，所以这一次就不能修改了。要修改就要下一次去修改。
> 所以实际上，CAS(Compare And Swap)就是比较和交换。

> 如果每次操作时候会读一下当前值是多少，读出来时候做一次CAS操作，把读出来的数据和期望值做个比较，如果比较成功，就把新的值设上去。CAS总是抱有乐观的态度，认为自己很有可能是能完成这个事情的。

> CAS有三个操作数（M, E, U）：内存值，期望值，更新的值。 比较内存中的值与期望的值是否相同，若相同则更新新的值，否则告知失败。一般操作会死循环重试操作。

	/**
	* 比较obj的offset处内存位置中的值和期望的值，如果相同则更新。此更新是不可中断的。
	* 
	* @param obj 需要更新的对象
	* @param offset obj中整型field的偏移量
	* @param expect 希望field中存在的值
	* @param update 如果期望值expect与field的当前值相同，设置filed的值为这个新值
	* @return 如果field的值被更改返回true
	*/
	public native boolean compareAndSwapInt(Object obj, long offset, int expect, int update);

>java并发（java.util.concurrent）中大量类使用了CAS操作，涉及到并发地方，都调用了sun.misc.Unsafe类的方法进行操作。结合volatile 实现了无锁的操作。volatile 修饰的属性，在每个线程修改后其他线程是可见的。


###1.2 CPU指令

> CAS是原子操作的，一个CPU指令，指令层面保证是原子操作的。


##2、无锁类

> Java中提供无锁类使用，底部使用CAS实现，与有锁（阻塞）方式比较，有锁导致线程被挂起，使之进入临界区之前，系统对其进行挂起。
相对来讲，无锁方式性能会更好一些，无锁方式不会线程挂起，只是会不断的重试。

> 如果一个线程在操作系统层面被挂起，它做一次上下文交换需要8万个使用周期，如果只是做一次重试操作，很可能不过是一个循环体，如果不是很复杂，也就是2，3, 十几条的以内的指令。

> 因此，相当于拿一个很小的成本，对赌8万个使用周期，除非运气差很是不成功，整体下来是赚的。所以无锁比有锁方式性能好很多。

+ 2.1 AtomicInteger
+ 2.2 Unsafe
+ 2.3 AtomicReference
+ 2.4 AtomicStampedReference
+ 2.5 AtomicIntegerArray
+ 2.6 AtomicIntegerFieldUpdater

###2.1 AtomicInteger

- 概述：无锁整数，继承Number类，

- 主要接口

	1.public final int get() //取得当前值
	2.public final void set(int newValue) //设置当前值
	3.public final int getAndSet(int newValue) //设置新值，并返回旧值
	4.public final boolean compareAndSet(int expect, int u)
	//如果当前值为expect，则设置为u
	5.public final int getAndIncrement() //当前值加1，返回旧值
	6.public final int getAndDecrement() //当前值减1，返回旧值
	7.public final int getAndAdd(int delta) //当前值增加delta，返回旧值
	8.public final int incrementAndGet() //当前值加1，返回新值
	9.public final int decrementAndGet() //当前值减1，返回新值
	10.public final int addAndGet(int delta) //当前值增加delta，返回新值

- 主要接口的实现

	//value值
	private volatile int value;
	
	/**
	 * Atomically increments by one the current value.
	 *
	 * @return the previous value
	 */
	public final int getAndIncrement() {
	    for (;;) {
	        int current = get();
	        int next = current + 1;
	        if (compareAndSet(current, next))
	            return current;
	    }
	}


###2.2 Unsafe

- 概述：个人理解获得一个类的首地址，然后根据偏移量获取类中某个字段的地址，可以获取，修改操作。也可以获取某个数组的首地址，然后根据偏移量获取某下标数据的地址，可以修改操作。

非公开API，在不同版本的JDK中， 可能有较大差异

非安全的操作，比如：
根据偏移量设置值
park()
底层的CAS操作: java不能直接访问操作系统底层，而是通过本地方法来访问，Unsafe类提供了硬件级别的原子操作，主要功能如下：
1.通过Unsafe类可以分配内存，可以释放内存

> 提供三个本地方法，allocateMemory、reallocateMemory、freeMemory,分别用于分配内存、扩充内存和释放内存，与C语言3个方法对应。

2.可以定位某个对象某个字段再内存中的位置，也可以修改对象的字段值，即使他是私有的。

```
	public native long allocateMemory(long l);
	public native long reallocateMemory(long l, long l1);
	public native void freeMemory(long l);
```

> 类中字段定位
字段的定位可能通过staticFieldOffset方法实现，该方法返回给定field的内存地址偏移量，这个值对于给定的filed是唯一的且是固定不变的。
getIntVolatile方法获取对象中offset偏移地址对应的整型field的值,支持volatile load语义。
getLong方法获取对象中offset偏移地址对应的long型field的值。

> 数组元素定位
arrayBaseOffset方法是一个本地方法，可以获取数组第一个元素的偏移地址。
arrayIndexScale方法也是一个本地方法，可以获取数组的转换因子，也就是数组中元素的增量地址。
将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。

3.挂起与恢复

> park方法实现一个线程的挂起，线程一直阻塞到超时或者中断等条件出现。
> unpark方法可以终止一个挂起的线程，使其恢复正常。
> 整个操作被封装在LockSupport类中，LockSupport中有各种版本的park方法，但最终被调用了Unsafe.park方法。

- 主要接口

	//获得给定对象偏移量上的int值
	public native int getInt(Object o, long offset);
	//设置给定对象偏移量上的int值
	public native void putInt(Object o, long offset, int x);
	//获得字段在对象中的偏移量
	public native long objectFieldOffset(Field f);
	//设置给定对象的int值，使用volatile语义
	public native void putIntVolatile(Object o, long offset, int x);
	//获得给定对象对象的int值，使用volatile语义
	public native int getIntVolatile(Object o, long offset);
	//和putIntVolatile()一样，但是它要求被操作字段就是volatile类型的
	public native void putOrderedInt(Object o, long offset, int x);

- 主要接口实现

	//获得获得一个类中value值得偏移量，其实也就是这个值对应C中的指针，也就是地址，那么就可以对其做任何操作。
	 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); 
	 
	//通过CAS 判断值是否设置成功
	 unsafe.compareAndSwapInt(this, valueOffset, expect, update);


###2.3 AtomicReference

- 概述：

对引用进行修改
是一个模板类，抽象化了数据类型

- 主要接口

	get()
	set(V)
	compareAndSet()
	getAndSet(V)

- 主要接口实现

	/**
     * Gets the current value.
     *
     * @return the current value
     */
    public final V get() {
        return value;
    }

    /**
     * Sets to the given value.
     *
     * @param newValue the new value
     */
    public final void set(V newValue) {
        value = newValue;
    }
    
    /**
     * Atomically sets to the given value and returns the old value.
     *
     * @param newValue the new value
     * @return the previous value
     */
    public final V getAndSet(V newValue) {
        while (true) {
            V x = get();
            if (compareAndSet(x, newValue))
                return x;
        }
    }


###2.4 AtomicStampedReference

- 概述：对某个值，在做cas操作时，这个值被改了两次，有改成原来的值，普通AtomicReference 无法识别是否改过，表示成功，这是错误的。此时必须使用AtomicStampedReference，添加了一个唯一的类似时间戳，能识别已经改了操作，那么这个CAS操作不成功。

ABA问题

- 主要接口

	//比较设置 参数依次为：期望值 写入新值 期望时间戳 新时间戳
	public boolean compareAndSet(V expectedReference,V newReference,int expectedStamp,int newStamp)
	//获得当前对象引用
	public V getReference()
	//获得当前时间戳
	public int getStamp()
	//设置当前对象引用和时间戳
	public void set(V newReference, int newStamp)

- 主要接口实现

	 //对饮用对象添加一个stamp唯一的时间戳
	 private static class Pair<T> {
        final T reference;
        final int stamp;
        private Pair(T reference, int stamp) {
            this.reference = reference;
            this.stamp = stamp;
        }
        static <T> Pair<T> of(T reference, int stamp) {
            return new Pair<T>(reference, stamp);
        }
    }
    private volatile Pair<V> pair;
    
    
    //stamp 与reference 期望值都与实际值相等
    public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) {
        Pair<V> current = pair;
        return
            expectedReference == current.reference &&
            expectedStamp == current.stamp &&
            ((newReference == current.reference &&
              newStamp == current.stamp) ||
             casPair(current, Pair.of(newReference, newStamp)));
    }
    


###2.5 AtomicIntegerArray

- 概述：对每个下标修改都是线程安全的。

支持无锁的数组

大量位运算，相对比较会快一点

static {
    int scale = unsafe.arrayIndexScale(int[].class);
    if ((scale & (scale - 1)) != 0)
        throw new Error("data type scale not a power of two");
    shift = 31 - Integer.numberOfLeadingZeros(scale);
}


4的二进制 100，前边补的0，这部分叫做leading, 32 - 3 = 29个0。  31-29 = 2。

base + i*4 ,第i个元素的地址。

i << 4 左移2位， 所以 i*4 = i<<2

  private static long byteOffset(int i) {
        return ((long) i << shift) + base;
  }

jdk 中使用位运算代替 十进制乘法，相对会快一些。

- 主要接口

	//获得数组第i个下标的元素
	public final int get(int i)
	//获得数组的长度
	public final int length()
	//将数组第i个下标设置为newValue，并返回旧的值
	public final int getAndSet(int i, int newValue)
	//进行CAS操作，如果第i个下标的元素等于expect，则设置为update，设置成功返回true
	public final boolean compareAndSet(int i, int expect, int update)
	//将第i个下标的元素加1
	public final int getAndIncrement(int i)
	//将第i个下标的元素减1
	public final int getAndDecrement(int i)
	//将第i个下标的元素增加delta（delta可以是负数）
	public final int getAndAdd(int i, int delta)
	
- 主要接口实现

	 //获取第i个元素的偏移量。
    public final int get(int i) {
        return getRaw(checkedByteOffset(i));
    }
	 //根据首地址的某个偏移量的地址的值。
    private int getRaw(long offset) {
        return unsafe.getIntVolatile(array, offset);
        
        
    int scale = unsafe.arrayIndexScale(int[].class); //获取数组的首地址
    if ((scale & (scale - 1)) != 0)
        throw new Error("data type scale not a power of two");
    shift = 31 - Integer.numberOfLeadingZeros(scale);
    

###2.6 AtomicIntegerFieldUpdater


- 概述：

让普通变量也享受原子操作

类似反射方式修改

- 主要接口

	AtomicIntegerFieldUpdater.newUpdater()
	incrementAndGet()

- 主要接口实现

- 小说明

1.Updater只能修改它可见范围内的变量。因为Updater使用反射得到这个变量。如果变量不可见，就会出错。
比如如果score申明为private，就是不可行的。

2.为了确保变量被正确的读取，它必须是volatile类型的。如果我们原有代码中未申明这个类型，那么简单得
申明一下就行，这不会引起什么问题。

3. 由于CAS操作会通过对象实例中的偏移量直接进行赋值，因此，它不支持static字段（Unsafe.
objectFieldOffset()不支持静态变量）。


##3、无锁算法详解

###3.1 无锁的Vector实现

>

 	/**
     * Appends the specified element to the end of this Vector.
     *
     * @param e element to be appended to this Vector
     * @return {@code true} (as specified by {@link Collection#add})
     * @since 1.2
     */
    public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }



 LockFreeVector

