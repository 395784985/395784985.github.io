#10-并发调试和JDK8新特性

+ 1. 多线程调试方法
	+ 1.1 eclipse 调试
+ 2. 线程dump堆及分析
	+ 2.1 jstack 3392
	+ 2.2 在%JAVA_HOME%/bin
	+ 2.3 分析死锁案例
+ 3. JDK8并发新支持
	+ 3.1 LongAdder
	+ 3.2 CompletableFuture
	+ 3.3 StampLock
	
##1. 多线程调试方法
###1.1 eclipse 调试
- 使用eclipse进行多线程调试
    //代码示例
	public class UnsafeArrayList {
		static ArrayList<Object> al = new ArrayList<Object>();
		static class AddTask implements Runnable {
			@Override
			public void run() {
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				for (int i = 0; i < 1000000; i++) {
					al.add(new Object());
				}
			}
		}
		public static void main(String[] args) {
			Thread t1 = new Thread(new AddTask(), "t1");
			Thread t2 = new Thread(new AddTask(), "t2");
			t1.start();
			t2.start();
			Thread t3 = new Thread(new Runnable(){
				@Override
				public void run() {
					while (true) {
						try {
							Thread.sleep(1000);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
				}
			}, "t3");
			t3.start();
		}
	}
 
 //执行会报以下错误
	Exception in thread "t1" java.lang.ArrayIndexOutOfBoundsException: 10
		at java.util.ArrayList.add(ArrayList.java:441)
		at thread.lscj.UnsafeArrayList$AddTask.run(UnsafeArrayList.java:34)
		at java.lang.Thread.run(Thread.java:745)
   
   ![调试截图1](./images/debug-eclipse1.png)
   ![调试截图2](./images/debug-eclipse2.png)
   ![调试截图2](./images/debug-eclipse3.png)
   ![调试截图2](./images/debug-eclipse4.png)
   ![调试截图2](./images/debug-eclipse5.png)
  
- eclipse并发设置

  -  图（1）设置：(默认)
  	点击：Window->Preferences->Java->Debug，找到default suspend policy for new breakpoints，默认选项为Suspend Thread。
  	表示执行到断点的线程暂停，未执行到断点的线程仍在执行。
  -  图（2和3）设置
    在断点处右击弹出菜单，选择breakpoint Properties,弹出设置框，设置暂停条件:
     勾选conditional 条件(Thread.getCurrentThread().equals("main")), 说明当线程名为main时暂停执行。
    Suspend Thread：表示执行到断点的线程暂停，未执行到断点的线程仍在执行。
    Suspend vm：表示执行到断点的所有线程暂停。
   	
  -  图（4和5）设置
    点击：Window->Preferences->Java->Debug，找到default suspend policy for new breakpoints，默认选项为Suspend Thread，改为Suspend VM。
    Suspend Thread：表示执行到断点的线程暂停，未执行到断点的线程仍在执行。
    Suspend vm：表示执行到断点的所有线程暂停。
   
   
##2. 线程dump堆及分析
###2.1 jstack 3392

###2.2 在%JAVA_HOME%/bin

###2.3 分析死锁案例

##3. JDK8并发新支持
###3.1 LongAdder
- 和AtomicInteger类似的使用方式
- 在AtomicInteger上进行了热点分离
- public void add(long x);
- public void increment();
- public void decreament();
- public void sum();
- public void longValue();
- public void intValue();

  ![](./images/longAdder.png)

###3.2 CompletableFuture
- 实现CompletionStage接口（40余个方法）
- Java 8中对Future增强版
- 支持流式调用
  state.thenApply(x -> square(x)).thenAccept(x -> System.out.println(x)).thenRun(() -> System.out.println())
- 完成后得到通知
  public class AskThreadTest{
	public class AskThread implements Runnable { 
		 CompletableFuture<Integer> re = null; 
		 public AskThread(CompletableFuture<Integer> re) { 
			this.re = re;  
		 } 
		 @Override 
		 public void run() {
			int myRe = 0;
			try {
				 myRe = re.get() * re.get(); 
			} catch (Exception e) {
			}
			 System.out.println(myRe); 
		}
	}
	public static void main(String[] args) throws InterruptedException { 
		final CompletableFuture<Integer> future = new CompletableFuture<>();
		new Thread(new AskThread(future)).start();
		// 模拟长时间的计算过程
		Thread.sleep(1000);
		// 告知完成结果 
		future.complete(60);
	}
  }
- 异步执行
  	public static Integer calc(Integer calc) {
		// 模拟执行了很长时间
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		return calc * calc;
	}
	public static void main(String[] args) throws InterruptedException { 
		final CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> calc(50));
		System.out.println(future.get());
	}

- 工厂方法
   static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier); 
   static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor); 
   static CompletableFuture<Void> runAsync(Runnable runnable); 
   static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor);

- 流式调用
    public static Integer calc(Integer calc) {
		// 模拟执行了很长时间
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		return calc * calc;
	}
	public static void main(String[] args) throws InterruptedException { 
		CompletableFuture<Void> fu = CompletableFuture.supplyAsync(() -> calc(50))
		.thenApply((i)->Integer.toString(i)).thenApply((str)->"\""+str+"\"").thenAccept(System.out::println);
		fu.get();
	}

- 组合多个CompletableFuture
  - public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn)
    //示例
	public static Integer calc(Integer para) {
		return para/2;
	}
    public static void main(String[] args) throws InterruptedException { 
		CompletableFuture<Void> fu = CompletableFuture.supplyAsync(() -> calc(50))
		.thenCompose((i)->CompletableFuture.supplyAsync(() -> calc(i)))
		.thenApply((str)->"\"" + str + "\"").thenAccept(System.out::println);
		fu.get();
	}
  

###3.3 StampLock
  ![](./images/stamplock.png)
- 读写锁改进
- 读不阻塞写
- StampedLock的实现思想
   - CLH自旋锁
   - 锁维护一个等待线程队列，所有申请锁，但是没有成功的线程都会记录在这个队列中。每个节点（一个节点代表一个线程），保存一个标记位（locked）,用于判断当前线程是否已经释放锁。
   - 当一个线程试图获得锁时，取得当前等待队列的尾部节点作为其前序节点。并使用类似如下代码判断前序节点是否已经成功释放锁。
   		while(pred.locked){}
   - 不会进行无休止的自旋，会在若干次自旋后挂起线程
      ![](./images/stamplock2.png)
      
