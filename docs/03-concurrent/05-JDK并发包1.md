#05-JDK并发包1

+ 1.各种同步工具的使用
	+ 1.1 ReentrantLock：通过lock/unlock，保证同一时刻只有一个线程访问。
		+ 1.1.1 可重入
		+ 1.1.2 可中断
		+ 1.1.3 可限时
		+ 1.1.4 公平锁
	+ 1.2 Condition：通过await/signalAll来控制线程的等待与激活执行。（等同于wait/notifyAll）
		+ 1.2.1 概述
		+ 1.2.2 主要接口
		+ 1.2.3 API详解
	+ 1.3 Semaphore：保证部分代码同一时刻只可以有N个线程能访问
		+ 1.3.1 概述
		+ 1.3.2 主要接口
	+ 1.4 ReadWriteLock：读写锁
		+ 1.4.1 概述
		+ 1.4.2 访问情况
		+ 1.4.3 主要接口
	+ 1.5 CountDownLatch：同步倒数计数器（内部一个整数），计数具有原子性，对多线程同时操作进行计数。
		+ 1.5.1 概述
		+ 1.5.2 主要接口
		+ 1.5.3 示意图
	+ 1.6 CyclicBarrier：让N个线程相互等待，等N个线程都执行到某一部时候再继续执行，依次循环。
		+ 1.6.1 概述
		+ 1.6.2 主要接口
		+ 1.6.3 示意图
	+ 1.7 LockSupport
		+ 1.7.1 概述
		+ 1.7.2 主要接口
		+ 1.7.3 与suppend()比较
		+ 1.7.4 中断响应
	+ 1.8 ReentrantLock实现
		+ 1.8.1 CAS状态
		+ 1.8.2 等待队列
		+ 1.8.3 park()
	+ 1.9 Synchronous：保证部分代码同一时刻只有一个线程能访问
	+ 2.0 Exchanger: 用于线程间数据交换，通过exchange方法控制多个线程的等待与执行，以及数据交换。整个操作是线程安全的。
	+ 2.1 AbstractQueueSynchroner：一个同步组件的基础框架，先进先出策略。ReadWriteLock,ReentrantReadWriteLock都是基于它实现的
+ 2.并发容器及典型源码分析
	+ 2.1 集合包装
		+ 2.1.1 HashMap
		+ 2.1.2 List
		+ 2.1.3 Set
	+ 2.2 ConcurrentHashMap
	+ 2.3 BlockingQueue
	+ 2.4 ConcurrentLinkedQueue
+ 3.其他线程安全工具
	+ ThreadLocal：通过为每个线程创建一个独立的变量副本，这样就不存在多线程同时访问，也就是线程安全的。
	
##1.各种同步工具的使用
### 1.1 ReentrantLock：通过lock/unlock，保证同一时刻只有一个线程访问。
- 1.1.1 可重入
	单线程可重复进入，但要重复退出
- 1.1.2 可中断
	lockinterruptibly()
- 1.1.3 可限时
	超时不能获得锁，就返回false，不会永久等待构成死锁
- 1.1.4 公平锁
	公平锁, java.util.concurrent.locks.ReentrantLock$FairSync.java
	非公平锁，java.util.concurrent.locks.ReentrantLock$UnFairSync.java
	
### 1.2 Condition：通过await/signalAll来控制线程的等待与激活执行。（等同于wait/notifyAll）
- 1.2.1 概述
	类似于Object.wait/Object.notify()
- 1.2.2 主要接口
	void await() throws interruptedException;
	void awaitUninterruptibly();
	long awaitNanos(long nanosTimeout) throws InterruptedException;
	boolean await(long time, TimeUnit unit) throws InterruptedException;
	boolean awaitUntil(Date deadline) throws InterruptedException;
	void signal();
	void signalAll();
- 1.2.3 API详解
	await()方法会使当前线程等待，同时释放当前锁，当其它线程中使用singal/singalAll时，线程会重新获得锁并继续执行。或者当前线程中断时，也能跳出等待。这和Object.await方法很相似。
	awaitUninterruptibly()方法与await()基本相同，但是它不会再等待过程中响应中断。
	singal()方法用于一个等待中的线程。相对的singalAll()方法唤醒所有等待的线程。这和Object.notify()方法相似。

### 1.3 Semaphore：保证部分代码同一时刻只可以有N个线程能访问（允许多个线程同时进入临界区）
- 1.3.1 概述
	共享锁
	运行多个线程同时进入临界区
- 1.3.2 主要接口
	public void acquire();
	public void acquireiUninterruptibly()
	public boolean tryAcquire();
	public boolean tryAcquire(long timeout, TimeUnit unit);
	public void release();

### 1.4 ReadWriteLock：读写锁 （允许多个线程无等待并发）
- 1.4.1 概述
	JDK5中提供的读写分离锁
- 1.4.2 访问情况
	读-读不互斥：读读之间不阻塞
	读-写互斥：读阻塞写，写也会阻塞读
	写-写互斥：写写阻塞。
	
- 1.4.3 主要接口
	private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
	private static readLock = readWriteLock.readLock();
	private static writeLock = readWriteLock.writeLock();

### 1.5 CountDownLatch：同步倒数计数器（内部一个整数），计数具有原子性，对多线程同时操作进行计数。
- 1.5.1 概述
	倒数计时器
	一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还需要进行个性设备、仪器的检查。只有等所有检查完毕后，引擎才能点火。这种场景就非常合适使用CountDownLatch。它可以使得点火线程，等待所有检查线程全部完工后，再执行。
- 1.5.2 主要接口
	static final CountDownLatch end = new CountDownLatch();
	end.countDown();
	end.await();
- 1.5.3 示意图

### 1.6 CyclicBarrier：让N个线程相互等待，等N个线程都执行到某一部时候再继续执行。
- 1.6.1 概述
	循环栅栏
	Cyclic意为循环，也就是说这个计数器可以反复使用。比如假设我们将计数器设置为10。那么凑齐第一批10个线程后，计数器就会归零，然后接着凑齐下一批10个线程。
- 1.6.2 主要接口
	public CyclicBarrier(int parties, Runnable barrierAction);
	barrierAction就是当计数器一次完成后，系统会执行的动作。
	await
- 1.6.3 示意图

### 1.7 LockSupport  中断线程，继续执行。
- 1.7.1 概述
	提供线程阻塞原
- 1.7.2 主要接口
	LockSupport.park();
	LockSupport.unpark(t1);
- 1.7.3 与suppend()比较
	不容易引起线程冻结
- 1.7.4 中断响应
	能够响应中断，但不抛异常。
	中断响应结果是，park函数的返回，可以从Thread.interrpted()中得到中断标志。
	
### 1.8 ReentrantLock实现
- 1.8.1 CAS状态
- 1.8.2 等待队列
- 1.8.3 park()

## 2.并发容器及典型源码分析
### 2.1 集合包装
- 2.1.1 HashMap
	Collections.synchronizedMap
	public static Map map = Collections.synchronizedMap(new HashMap());
	
- 2.1.2 List
	synchronizedList
	
- 2.1.3 Set
	synchronizedSet

### 2.2 ConcurrentHashMap
  高性能HashMap
  
### 2.3 BlockingQueue
  阻塞队列
  
### 2.4 ConcurrentLinkedQueue

