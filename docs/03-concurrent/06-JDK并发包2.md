#06.JDK并发包2

+ 1. 线程池的基本使用
	+ 1.1 为什么要是用线程池
	+ 1.2 JDK为我们提供了哪些支持
	+ 1.3 线程池的使用
		+ 1.3.1 线程池的种类
		+ 1.3.2 不同线程池的共同性
+ 2. 扩展和增强线程池
	+ 2.1 回调接口
	+ 2.2 拒绝策略
	+ 2.3 自定义ThreadFactory
+ 3. 线程池及核心代码分析
+ 4. ForkJoin
	+ 4.1 思想
	+ 4.2 使用接口
		+ 4.2.1 RecursiveAction
		+ 4.2.2 RecursiveTask
	+ 4.3 简单例子
	+ 4.4 实现要素
		+ 4.4.1 工作窃取
+ 5. 其他

##1. 线程池的基本使用
###1.1 为什么要是用线程池
- 原因
	- 单个任务处理的时间比较短，且需要处理的任务数量大
- 场景
	- 线程池是为突然爆发大量的线程(并发)而设计的，通过几个有限的固定线程为大量的操作服务，减少创建和销毁所需的时间，从而提高效率。
	- 可根据系统情况调整执行的线程数量，防止消耗过多内存，并可充分利用CPU。
- 简单线程池的实现

###1.2 JDK为我们提供了哪些支持
- 内置线程池
	![](./images/threadpool.png)
	
###1.3 线程池的使用
- 1.3.1 线程池的种类
	- newFixedThreadPool
		固定数量的线程池，每提交一个任务就是一个线程，直到达到线程池最大数，然后在有任务进入等待队列，直到有任务处理完成。
	- newSingleThreadExecutor
		单个线程的线程池，线程池中只有一个线程在工作，单线程串行执行任务。
	- newCachedThreadPool
		可缓存线程池，当线程池大小超过了处理任务所需的线程，那么就回收部分空闲（一般60秒无执行）的线程；当有任务来时，又智能添加新的线程。
	- newScheduledThreadPool
		大小无限制的线程池，支持定时和周期性的执行线程
- 1.3.2 不同线程池的共同性
	线程池构造函数详解

###1.4 线程池使用的小例子
- 1.4.1 简单线程池
- 1.4.2 SheculedThreadPool

##2. 扩展和增强线程池
###2.1 回调接口
- beforeExecute
- afterExecute
- terminated

###2.2 拒绝策略
###2.3 自定义ThreadFactory

##3. 线程池及核心代码分析
###4. ForkJoin
###4.1 思想
  ![](./images/forkjoin.png)
  
###4.2 使用接口
- 4.2.1 RecursiveAction
	无返回值
- 4.2.2 RecursiveTask
	有返回值
	
###4.3 简单例子
###4.4 实现要素
- 4.4.1 工作窃取
  ![](./images/gongzuoqiequ.png)
  
##5. 其他