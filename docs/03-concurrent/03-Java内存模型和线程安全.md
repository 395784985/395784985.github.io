# 03 Java内存模型和线程安全

> 多任务和高并发是衡量一台计算机处理器的能力重要指标之一。
> 一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数。

+ 内存模型
	+ 计算机内存模型
	+ java 内存模型
	+ 内存间的交互
	+ 指令重排
	+ 内存屏障
	+ happen-before
+ 相关特性
	+ 原子性
	+ 有序性
	+ 可见性
	+ Happen-Before
	+ 线程安全的概念

##1、Java 内存模型

+ 硬件内存模型
+ java虚拟机内存模型
+ 内存间的交互
+ 指令重排
+ 内存屏障
+ happen-before

####1.1 计算机内存模型

> 由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。

> 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的，后续将介绍Java内存模型。
	
![](http://images.cnitblog.com/i/475287/201403/091102484251967.jpg)

> 除此之外，为了使得处理器内部的运算单元能竟可能被充分利用，处理器可能会对输入代码进行乱起执行（Out-Of-Order Execution）优化，处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果准确性。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Recorder）优化。

####1.2 java 内存模型

> 定义Java内存模型并不是一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发操作不会产生歧义；但是，也必须得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存等）来获取更好的执行速度。

####1.2.1 主内存与工作内存

- 内存模型目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。变量指实例字段、静态字段和构成数组对象的元素。

- 所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比）。
- 线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。
- 不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示

![](http://images.cnitblog.com/i/475287/201403/091134177063947.jpg)

> 这里的主内存、工作内存与Java内存区域的java堆、栈、方法区不是同一层次内存划分。

####1.2.3 内存间的交互
> 主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存的实现细节。
> 以下八中操作来完成。

- lock（锁定）：作用于主内存的变量，把一个变量标识为线程锁定独占的状态。
- unlock(解锁)：作用于主内存的变量，把一个线程锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read(读取)：作用于主内存的变量，把一个变量从主内存传输到工作内存，以便随后的load操作。
- load(载入)：作用于工作内存的变量，把read操作从主内存获得的变量值放入工作内存的变量副本中。
- use(使用)：作用于工作内存的变量，把工作内存的变量传值给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作
- assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- write(写入)：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

1.不允许read和load、store和write操作之一单独出现
2.不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
3.不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
4.一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
5.一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
6.如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
7.如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
8.对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

> 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。

####1.2.4 指令重排

> 在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：

1.编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。
2.指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3.内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：

![](http://images.cnitblog.com/i/475287/201403/091511346284594.png)

####1.2.5 内存屏障

> 为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。
1.保证特定操作的执行顺序。
2.影响某些数据（或则是某条指令的执行结果）的内存可见性。

- Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种：

![](http://images.cnitblog.com/i/475287/201403/091516513623330.png)

	编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。
	
	Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。
	
	这和java有什么关系？上面java内存模型中讲到的volatile是基于Memory Barrier实现的。
	
	如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，并在读这个字段之前插入一个Read-Barrier指令。这意味着，如果写入一个volatile变量，就可以保证：
	
	1.一个线程写入变量a后，任何线程访问该变量都会拿到最新值。
	2.在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。

####1.2.6 happen-before

> 在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。

- 程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。
- 监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。
- volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
- 传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。

##2、相关特性

+ 原子性
+ 有序性
+ 可见性
+ Happen-Before
+ 线程安全的概念

###2.1、原子性

- 原子性是指一个操作是不可中断的。即使是在多线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

> i++是原子操作吗？
> long整形读取是不是原子操作

###2.2、有序性

- 在并发时，程序的执行可能就会出现乱序
- 一条指令是可以分为很多步骤的

> 取指IF

> 译码和取寄存器操作数ID

> 执行或者有效地址计算EX

> 存储器访问MEM

> 写会WB


> 指令1 IF ID EX MEM WB

> 指令2 IF ID EX MEM WB

- 指令重拍可以使流水线更加顺畅

> A=B+C 的处理

> 加载B值到内存R1：IF ID EX MEM WB 

> 加载C值到内存R2：   IF ID EX MEM WB

> 相加R1和R2放到R3：     IF ID x  EX MEM WB

> 存储R3到A:                IF x  ID EX MEM WB

> 以上为操作过程，x 为等待气泡，计算机要进行指令重拍 的方式来进行优化 这些等待气泡，加快处理时间。

###2.3、可见性

- 可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能立即知道这个修改。
> 编译器优化
> 硬件优化（如写吸收，批操作）
- java虚拟机层面的可见性，也会进行一些优化

	public class VisibilityTest extends Thread { 
		private boolean stop; 
		public void run() { 
			int i = 0; 
			while(!stop) {
			 i++; 
			 } 
			 System.out.println("finish loop,i=" + i); 
		 } 
		 public void stopIt() { 
		 	stop = true; 
		 } 
		 public boolean getStop(){
		  	return stop; 
		 }
	}
	
	public static void main(String[] args) throws Exception { 
		VisibilityTest v = new VisibilityTest(); 
		v.start(); 
		Thread.sleep(1000); 
		v.stopIt(); 
		Thread.sleep(2000); 
		System.out.println("finish main"); 
		System.out.println(v.getStop()); 
	}

> -server 模式运行上述代码，永远不会停止
> 原因是由于虚拟机的优化，导致stop 这个属性无法是可见性的，导致不会被修改，一直执行下去。，
> 解决方法 添加volatile 属性，使得多线程可见。

###2.4、Happen-Before

- 程序顺序原则：一个线程内保证语义串行行,比如 a = 1; b = a+ 1; 指令重排等程序优化不能打乱程序语义顺序。
- volatile 规则:volatile 变量的写，先发生于读，这保证了volatile变量的可见性。
- 锁规则：解锁（unlock）必然发生在随后的加锁（lock）前
- 传递性：A先于B，B先于C，那么A必然先于C。

- 线程的start()方法先于它的每一个执行动作。
- 线程的所有操作先于线程的终结（Thread.join()）.
- 线程的中断（interrupt()）先于被中断线程的代码。
- 对象的构造函数执行结束先于finalze()方法。

###2.5、线程安全的概念

- 指某个函数、函数库在多线程环境中被调用时，能够正确地处理各个线程的局部变量，使程序功能正确完成。

- 多线程对共享数据的访问或修改，能够正确的先后执行，而不会导致结果不一致问题。
> 由于cpu，虚拟机优化阻塞等原因导致两个线程对某个数据的访问先后是不确定的。所以会产生数据错误，不一致问题。
> 解决方式：加锁 synchronized, 同一时间只让一个线程进行执行,解决数据错乱问题。
